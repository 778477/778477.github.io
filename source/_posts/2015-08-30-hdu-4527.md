---
layout: post
title: 'hdu 4527'
date: '2015-08-30'
header-img: "img/home-bg.jpg"
tags:
     - ACM
     
author: '778477'
---


[小明系列故事——玩转十滴水](http://acm.hdu.edu.cn/showproblem.php?pid=4527)

题目大意：游戏是在一个6*6的方格内进行的，每个格子上有一滴水或者没有水滴。水滴分为四个等级1~4。初始时你有十滴水，通过把水加入格子内的水滴，会让水滴升1级。你也可以把水放到空格子内，这样会在这个格子里面产生一个1级的水滴。当水滴等级大于4时则会爆裂为四个小水滴，并向四个方向飞溅。每个飞溅的小水滴碰到其他水滴后会融入其中，使其升一级或者爆裂，以此类推。飞溅的小水滴互不干扰，运动速度相等(1秒可以移动一个格子的距离)。水滴爆裂后就消失掉了。

![4527-1](http://acm.hdu.edu.cn/data/images/4527-1.jpg)


输入：
题目包含多组测试用例；
对于每组数据，首先是6行，每行有6个整数数字，每个数字的范围为0~4；当数字为0时，表示空格子，当数字为1~4时，表示1~4级的水滴；
然后第七行是一个整数m，表示有m个操作；接下来是m行，每行有两个整数x, y ，表示在(x,y)放入一滴水。
特别说明：每次都是在全部的水滴静止后才进行下一次操作，也就是说只有在方格内没有任何飞溅的小水滴时才能放入一滴水。

[Technical Specification]

1 <= m <= 10

1 <= x, y <= 6



输出：
对于每组测试数据，请输出m个操作之后6*6方格内水滴的样子，每组数据的输出后面跟着一个空行。


思考：水滴的爆裂 和 水滴的飞溅一定同时进行，以保证每一个运动时刻游戏状态都是正确的！


```
//
//  main.cpp
//  hdu 4527
//
//  Created by miaoyou.gmy on 15/8/30.
//  Copyright (c) 2015年 miaoyou.gmy. All rights reserved.
//

#include <iostream>
#include <string.h>
#include <queue>
using namespace std;

struct node{
    int x,y,d;
    node(int _x = 0,int _y = 0,int _d = 0):x(_x),y(_y),d(_d){}
};

const int N(6);
int maze[N][N];
queue<node> Q;
const int dir[4][2] = { {0,1},{1,0},{-1,0},{0,-1} };

bool judge(const int x,const int y){
    return (x>-1&&x<N&&y>-1&&y<N);
}

void output(){
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++){
            if(j == 0) printf("%d",maze[i][j]);
            else printf(" %d",maze[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

void deal(const int x,const int y){
    maze[x][y] = 0;
    for(int i=0;i<4;i++){
        int xx = x+dir[i][0];
        int yy = y+dir[i][1];
        if(judge(xx, yy)){
            Q.push(node(xx,yy,i));
        }
    }
}

void found(){
    for(int i=0;i<N;i++){
        for(int j=0;j<N;j++){
            if(maze[i][j] > 4) deal(i, j);
        }
    }
}

void bfs(){
    while (!Q.empty()) {
        size_t size = Q.size();
        while(size--){
            node now = Q.front();
            Q.pop();
            
            if(maze[now.x][now.y] > 0) maze[now.x][now.y]+=1;
            else{
                int afterx = now.x+dir[now.d][0];
                int aftery = now.y+dir[now.d][1];
                if(judge(afterx, aftery)){
                    Q.push(node(afterx,aftery,now.d));
                }
            }
        }
        found();
    }
}


int main(int argc, const char * argv[]) {
//    freopen("in.txt", "r", stdin);
    int a,m,x,y;
    while(~scanf("%d",&a)){
        maze[0][0] = a;
        for(int i=1;i<N;i++){
            scanf("%d",&maze[0][i]);
        }
        
        for(int i=1;i<N;i++){
            for(int j=0;j<N;j++){
                scanf("%d",&maze[i][j]);
            }
        }
        
        scanf("%d",&m);
        while(m--){
            scanf("%d%d",&x,&y);
            --x,--y;
            if(maze[x][y] < 4) maze[x][y]+=1;
            else{
                deal(x,y);
                bfs();
            }
        }
        output();
    }
    return 0;
}

```

![hdu-4527-accepted](https://raw.githubusercontent.com/778477/778477.github.io/master/img/hdu-4527-accepted.png)



> 如有任何知识产权、版权问题或理论错误，还请指正。
>
> 转载请注明原作者及以上信息。
